# [设计模式](https://time.geekbang.org/column/article/160463)

[TOC]



![设计模式](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)



**面向对象 设计原则 设计模式 编程规范 代码重构的关系**

> 面向对象：三种编程范式（面向过程编程 面向对象编程 函数式编程）中的一种，具有封装 继承 抽象 多态的特性，是很多设计原则和设计模式实现的基础
>
> 设计原则：指导代码设计的经验总结
>
> 设计模式：针对软件开发中经常遇到的设计问题，提出的一套解决方案 主要目的是为了提供可扩展性 
>
> 编程规范：提高代码的可读性
>
> 重构：不断保持代码质量的手段





## 面向对象



![](https://static001.geekbang.org/resource/image/04/c9/041e22cac6ce2ba3481e246c119adfc9.jpg)







![](https://static001.geekbang.org/resource/image/98/98/9894233257994a69102afa960692ce98.jpg)





****

## 设计模式

**==目的是解耦==**



### 创建型：

**==将对象的创建和使用解耦==**



#### 单例模式

使用单例模式的场景：

+ 表示业务上的全局唯一类：如数据库连接池、配置类，数据在系统中只需要保存一份的
+ 解决资源访问冲突的问题：一个资源只由一个对象管理，锁可以用对象锁就能保证线程安全



#### 工厂模式

使用工厂模式的场景：

+ 对象的创建过程过于复杂，需要将其与其余代码解耦



作用：

+ 封装变化
+ 代码复用
+ 隔离复杂性



#### 建造者模式

使用场景：

当构造参数过多时使用 解决构造参数过多可以用默认构造方法 + set方法 但有些情况下这个方式不管用

+ 必填参数过多时，必填参数需要放在构造函数中，set方法中的只是选填参数
+ 当参数之间有约束性关系时，构造方法 + set方法没有地方放置校验逻辑
+ 如果要创建不可变对象时 那就没有set方法
+ 避免构造对象时 对象处于无效状态 当所有需要填充的属性填充了之后 对象才会暴露出来



#### 原型模式

使用场景：

> 当创建的对象的成本过大，而同一个类的对象差别不大时（很多字段都相同），我们可以通过拷贝现有的对象（原型）的方式来创建新对象，以节省创建成本（就是复用）
>
> 创建成本过大：指对象中的某些属性需要通过RPC、数据库、网络、文件等慢速IO或者是需要做排序、哈希
>
> 拷贝：分为深拷贝和浅拷贝



### 结构型：

**==将不同功能的代码解耦==**



#### 代理模式

**概念**：

> 在不改变被代理类代码的前提下，为其增加附加功能



**实现形式**：

+ **静态代理**：

  + 组合：需要被代理类和代理类实现同一个接口
  + 继承：用于被代理类没有实现接口 且没有办法修改源代码的情况（依赖第三方的库）

  静态代理出现的问题: 代码中类的数量迅速膨胀 每个被代理类都需要一个代理类

+ **动态代理**：

  动态生成代理类（通过反射），然后替换掉被代理类



**使用场景**：

> 代理类中放置与业务功能没有直接关系的非功能性需求：如限流、日志、幂等、缓存、鉴权、统计、事务
>
> 将这些功能与业务功能解耦





#### 桥接模式

**概念**：

> 当一个类存在多个独立变化的维度，通过组合的方式，让这些维度可以独立变化，避免继承层次过深



**使用场景**：

> 当某个对象有两个或者多个维度 将多个维度变为抽象类/接口 通过组合 结合在一起 避免继承爆炸
>
> 举个很简单的例子，现在有两个纬度
> Car 车 （奔驰、宝马、奥迪等）
> Transmission 档位类型 （自动挡、手动挡、手自一体等）
> 按照继承的设计模式，Car是一个Abstract基类，假设有M个车品牌，N个档位一共要写M\*N个类去描述所有车和档位的结合。
> 而当我们使用桥接模式的话，我首先new一个具体的Car（如奔驰），再new一个具体的Transmission（比如自动档）。然后奔驰`.set`手动档就可以了。
> 那么这种模式只有M+N个类就可以描述所有类型，这就是M\*N的继承类爆炸简化成了M+N组合。



#### 装饰器模式

**概念**：

> 用组合替代继承，装饰类和原始类继承相同的父类，可以实现对原始类的多次嵌套，是对原始类功能的增强



使用场景：

> 也是组合优于继承的思想，当需要增强某个类的功能时，采用组合的方式，装饰类持有原始类的对象，两者实现同一个抽象类或者接口，以实现嵌套使用的效果（增强一个功能 就嵌套一个装饰类）
>
> 典型例子：`java.io`







#### 适配器模式

概念：

> 用来做适配的，将不兼容的接口转化为兼容的接口（如type-c转接口）



使用场景：

 + 封装有缺陷或者设计不合理的接口
 + 统一多个类的接口设计
 + 替换掉调用的外部系统
 + 兼容老版本接口 老版本接口不变 但是里面的实现由新的类提供





#### 门面模式

概念：

> 在子系统之上定义一组高层接口，让子系统更加易用



使用场景：

+ 提高系统的易用性，封装系统的底层实现，隐藏复杂性，对外提供一组更易用的接口
+ 提高性能，比如原来需要请求三个接口，现在可以用一个接口封装三个接口的内容，从而减少请求次数
+ 可以作为分布式事务的解决方案，将必须作为原子性的多个操作合在一个接口中，利用将分布式事务转化为本地事务的问题



#### 组合模式

概念：

> 将一组对象组织成树形结构，以表示一种整体-部分的层次结构，使得我们可以统一对部分和整体的处理逻辑



使用场景：

所处理的对象要能被表示成树形结构，如文件夹和文件，部门和员工，抽象出一个基类，整体和部分各自为实现类继承基类



#### 享元模式

共享单元，共享重复的**不可变对象**，或者共享对象中的重复的字段，在内存中只保留一份实例，供其他地方引用，来达到节省内存的目的

实现：通过工厂模式，在工厂类中用一个map缓存已经创建的享元对象来达到复用的目的



### 行为型：

**==将不同的行为解耦==**



#### 观察者模式

概念：

> 在对象之间定义一个一对多的依赖关系，当一个对象（被观察者）的状态变化时，所有依赖的对象（观察者）都会自动收到通知



使用场景：

> 当一个事件发生时，会影响到很多其他模块的状态（考虑到模块可能会不断增多）



观察者模式和生成-消费模型的区别：

+ 一对多和多对多
+ 消息被多个对象消费和消息被一个对象消费





